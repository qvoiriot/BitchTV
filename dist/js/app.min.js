angular.module('BitchTV', [
    'ngRoute',
    'ngResource',
    'ui.bootstrap',
    'blockUI',
    'BitchTV.plugins',
    'BitchTV.filters'
])
    .config(["$routeProvider", function($routeProvider) {
        $routeProvider.when('/channels', {templateUrl: 'views/channels.html'});
        $routeProvider.when('/programs/:dateCode', {templateUrl: 'views/programs.html', controller: 'DefaultController'});
        $routeProvider.when('/channel/:channelId', {templateUrl: 'views/channel.html', controller: 'DefaultController'});
        $routeProvider.when('/search/:keywords', {templateUrl: 'views/search.html', controller: 'DefaultController'});
        $routeProvider.otherwise({redirectTo: '/channels'});
    }])
    .constant('Constants', {
        logosPath: "assets/img/logos/"
    });

angular.module('BitchTV.plugins', []);
angular.module('BitchTV.filters', []);

angular.module('BitchTV').controller('DefaultController',
    ["$scope", "$routeParams", function ($scope, $routeParams) {
        $scope.$routeParams = $routeParams;
    }]

);

angular.module('BitchTV').constant('Config', {
    apiUrl: "http://localhost:8002"
});
angular.module('BitchTV.filters')
    .filter('joinBy', function () {
        return function (input,delimiter) {
            return (input || []).join(delimiter || ',');
        };
    });
angular.module('BitchTV').factory('ChannelService', ["ProgramService", "ChannelsResource", "UtilService", "Constants", function (ProgramService, ChannelsResource, UtilService, Constants) {
    var channels = ChannelsResource.query();

    return {
        getChannelLogoSrc: function(channel) {
            //if int => channelId
            if(UtilService.isInt(channel)) {
                channel = getSync(channel);
            }
            if(channel && channel.icon) {
                var split = channel.icon.src.split('/');
                var logoImageName = split[split.length - 1];
                return Constants.logosPath + logoImageName;
            }
        },

        get: function(channelId, callback) {
            ChannelsResource.get({id: channelId}, function (channel) {
                ProgramService.getForChannel(channelId, function (programs) {
                    channel.programs = programs;
                    callback(channel);
                });
            });
        },
        getSync: getSync
    };

    function getSync(channelId) {
        for(var i=0; i<channels.length; i++) {
            if(channels[i].id == channelId) {
                return channels[i];
            }
        }
    }
}]);
angular.module('BitchTV').directive('bitchTvChannel', ["ChannelsResource", "ChannelService", "WaitingService", function (ChannelsResource, ChannelService, WaitingService) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/channel/channel.html',
        link: function(scope, element, attrs) {
            var channelId = attrs.channelId;
            WaitingService.start(function() {
                ChannelService.get(channelId, function(channel) {
                    scope.channel = channel;
                    WaitingService.stop();
                });
            });
            scope.getChannelLogoSrc = ChannelService.getChannelLogoSrc;
        }
    };
}]);
angular.module('BitchTV').directive('bitchTvChannelList', ["$location", "ChannelsResource", "ChannelService", function ($location, ChannelsResource, ChannelService) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/channelList/channelList.html',
        link: function(scope, element, attrs) {
            scope.channels = ChannelsResource.query();
            scope.getChannelLogoSrc = ChannelService.getChannelLogoSrc;
            scope.redirectToChannel = function(channelId) {
                $location.path('/channel/' + channelId);
            };
        }
    };
}]);
angular.module('BitchTV').directive('bitchTvFooter', ["DateUtilService", "$interval", function (DateUtilService, $interval) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/footer/footer.html',
        link: function(scope, element, attrs) {
            scope.todayDate = DateUtilService.currentDate();
            scope.time = DateUtilService.currentTime();
            
            $interval(function() {
                scope.todayDate = DateUtilService.currentDate();
                scope.time = DateUtilService.currentTime();
            }, 1000);
        }
    };
}]);
angular.module('BitchTV').directive('bitchTvJumbotron', ["DateUtilService", function (DateUtilService) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/jumbotron/jumbotron.html',
        scope: { title: '@', image: '@'},
        link: function(scope, element, attrs) {
            scope.date = "We are the " + DateUtilService.currentDate() + ". It is " + DateUtilService.currentTime();
        }
    };
}]);
angular.module('BitchTV').directive('bitchTvMenu', ["$location", "$timeout", function ($location, $timeout) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/menu/menu.html',
        link: function(scope, element, attrs) {
            scope.isCollapsed = true;
            scope.search = function(keyword) {
                $location.path('/search/' + keyword);
            };

            //sale
            $(".navbar-nav li a").click(function(event) {
                $(".navbar-collapse").collapse('hide');
            });
        }
    };
}]);

angular.module('BitchTV').factory('ProgramService', ["ProgramsResource", "DateUtilService", function (ProgramsResource, DateUtilService) {
    var cachedPrograms;

    return {
        getForChannel: function(channelId, callback) {
            getPrograms(function (programs) {
                var channelPrograms = [];
                for(var i=0; i<programs.length; i++) {
                    if(channelId == programs[i].channel) {
                        channelPrograms.push(programs[i]);
                    }
                }
                callback(channelPrograms);
            });
        },

        getForDate: function(dateCode, callback) {
            var dateInfo = DateUtilService.getDateInfoForCode(dateCode);
            var currentDate = DateUtilService.currentDate();
            var currentTime = DateUtilService.currentTime();
            var programsForDate = [];

            getPrograms(function (programs) {
                for(var i=0; i<programs.length; i++) {
                    var dateNow = DateUtilService.getDayMonthYearByPrograms(programs[i].start);
                    var timeStart = DateUtilService.getHoursMinutesByPrograms(programs[i].start);
                    var timeStop = DateUtilService.getHoursMinutesByPrograms(programs[i].stop);

                    if(dateCode == 'now' && currentDate == dateNow && timeStart <= currentTime && timeStop >= currentTime) {
                        programsForDate.push(programs[i]);
                    }
                    else if(dateCode == 'tonight' && currentDate == dateNow && timeStart >= dateInfo.startTime) {
                        programsForDate.push(programs[i]);
                    }
                    else if(currentDate == dateNow && timeStart >= dateInfo.startTime && timeStop <= dateInfo.stopTime && timeStart <= dateInfo.stopTime) {
                        programsForDate.push(programs[i]);
                    }
                }
                callback(programsForDate);
            });
        },

        getProgramImgSrc: function(program, channelIcon) {
            if(program.icon)
                return program.icon.src;
            else {
                return channelIcon;
            }
        },

        hasSpecificImage: function(program) {
            return program.icon;
        },

        getPrograms: getPrograms
    };

    function getPrograms(callback) {
        if(!cachedPrograms) {
            ProgramsResource.query(function(programs) {
                cachedPrograms = filterResource(programs);
                callback(cachedPrograms);
            });
        } else
            callback(cachedPrograms);

        function filterResource(programs) {
            var currentDate = DateUtilService.currentDate();
            var currentTime = DateUtilService.currentTime();

            var programsFilteredByDate = [];
            for(var i=0; i<programs.length; i++) {
                var dateNow = DateUtilService.getDayMonthYearByPrograms(programs[i].start);
                var timeStart = DateUtilService.getHoursMinutesByPrograms(programs[i].start);

                if(dateNow >= currentDate && timeStart >= currentTime) {
                    programsFilteredByDate.push(programs[i]);
                }
            }
            return programsFilteredByDate;
        }
    }
}]);
angular.module('BitchTV').directive('bitchTvProgram', ["ProgramService", "DateUtilService", "ChannelService", function (ProgramService, DateUtilService, ChannelService) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/program/program.html',
        scope: {program: '=', channelIcon: '@'},
        link: function(scope, element, attrs) {
            
            scope.displayInfo = false;

            scope.getProgramImgSrc = function () {
                return ProgramService.getProgramImgSrc(scope.program, scope.channelIcon);
            };

            scope.hasSpecificImage = ProgramService.hasSpecificImage;

            scope.$watch('program', function (newValue) {
                if(newValue) {
                    scope.program.channelLogo = ChannelService.getChannelLogoSrc(scope.program.channel);
                    scope.program.date = DateUtilService.getDayMonthYearByPrograms(scope.program.start);
                    scope.program.hours = {
                        start : DateUtilService.getHoursMinutesByPrograms(scope.program.start),
                        stop : DateUtilService.getHoursMinutesByPrograms(scope.program.stop)
                    };
                    scope.start = DateUtilService.getDayMonthYearByPrograms(scope.program.start) + ' at ' + DateUtilService.getHoursMinutesByPrograms(scope.program.start);
                    scope.stop  = DateUtilService.getDayMonthYearByPrograms(scope.program.stop) + ' at ' + DateUtilService.getHoursMinutesByPrograms(scope.program.stop);
                }
            });
        }
    };
}]);
angular.module('BitchTV').directive('bitchTvProgramList', ["ChannelService", "ProgramService", "WaitingService", function (ChannelService, ProgramService, WaitingService) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/programList/programList.html',
        link: function(scope, element, attrs) {
            WaitingService.start();
            ProgramService.getForDate(attrs.dateCode, function(programs) {
                scope.programs = programs;
                WaitingService.stop();
            });
            scope.getChannelLogoSrc = ChannelService.getChannelLogoSrc;
            scope.title = getTitle(attrs.dateCode);
        }
    };

    function getTitle(dateCode) {
        switch (dateCode) {
            case 'now':
                return 'Now on TV';
                break;
            case 'morning':
                return 'This morning on TV';
                break;
            case 'afternoon':
                return 'This afternoon on TV';
                break;
            case 'tonight':
                return 'Tonight on TV';
                break;
        }
    }
}]);
angular.module('BitchTV').factory('ChannelsResource',
    ["ResourceFactory", "Config", function(ResourceFactory, Config) {
        var resourcesInfo = {
            route : "/channels.json",
            idField : 'id',
            apiUrl : 'api'
        };
        var ChannelsResource =  ResourceFactory.createResource(resourcesInfo);

        ChannelsResource.get = function(options, callback) {
            ChannelsResource.query(function (channels) {
                for(var i=0; i<channels.length; i++) {
                    if(channels[i].id == options.id) {
                        callback(channels[i]);
                    }
                }
            });
        };

        return ChannelsResource;
    }]);
angular.module('BitchTV').factory('ProgramsResource',
    ["ResourceFactory", "Config", function(ResourceFactory, Config) {
        var resourcesInfo = {
            route : "/programs.json",
            idField : 'id',
            apiUrl : 'api'
        };
        return ResourceFactory.createResource(resourcesInfo);
    }]);
angular.module('BitchTV').factory('SearchService', ["ProgramService", "BasicSearchService", function (ProgramService, BasicSearchService) {
    return {
        search: function(keywords, callback) {
            ProgramService.getPrograms(function (programs) {
                var results = BasicSearchService.searchFor(keywords, programs);
                callback(results);
            });
        }
    };
}]);
angular.module('BitchTV').directive('bitchTvSearch', ["SearchService", "ChannelService", "WaitingService", function (SearchService, ChannelService, WaitingService) {
    return {
        restrict: 'E',
        templateUrl: 'components/bitchTV/search/search.html',
        scope: {'keywords': '@'},
        link: function(scope, element, attrs) {
            WaitingService.start(function() {
                SearchService.search(scope.keywords, function (programs) {
                    scope.programs = programs;
                    WaitingService.stop();
                });
            });

            scope.getChannelLogoSrc = ChannelService.getChannelLogoSrc;
        }
    };
}]);
angular.module("BitchTV.plugins").factory('ModalService',
    ["$modal", function($modal) {
        var ModalService = function(options) {
            this.instance = null;
            this.parentScope = options.parentScope;
            this.templateUrl = options.templateUrl;
            this.template = options.template;
            this.scopeData = {
                functions: options.scopeFunctions,
                watchers: options.scopeWatchers,
                data: options.scopeData
            };
            this.openned = false;
            this.scope = null;
        };

        ModalService.prototype.open = function(callback) {
            var modalOptions = this.createModalOptions();

            var self = this;
            try {
                this.instance = $modal.open(modalOptions);
                this.instance.opened.then(function() {
                    self.openned = true;
                    if(callback) callback(null);
                }, function(err) {
                    if(callback) callback(err);
                });
            } catch(err) {
                throw err;
            }
        };

        ModalService.prototype.isOpen = function() {
            return this.openned;
        };

        ModalService.prototype.close = function() {
            if(this.instance) {
                this.instance.close();
                this.openned = false;
            }
        };

        ModalService.prototype.createModalOptions = function() {
            var self = this;
            var modalOptions = {
                controller: ["$scope", function ($scope) {
                    //Functions
                    for(var key in self.scopeData.functions) {
                        $scope[key] = createCallbackWithScope(self.scopeData.functions[key], $scope);
                    }
                    $scope.closeModal = function () {
                        $scope.$close();
                    };

                    //Variables
                    for(var key in self.scopeData.data) {
                        $scope[key] = self.scopeData.data[key];
                    }

                    //Watchers
                    for(var key in self.scopeData.watchers) {
                        if(key[0] === '[') {
                            $scope.$watchCollection(key, createCallbackWithScope(self.scopeData.watchers[key], $scope));
                        } else {
                            $scope.$watch(key, createCallbackWithScope(self.scopeData.watchers[key], $scope));
                        }
                    }

                    self.scope = $scope;
                }]
            };
            if(this.templateUrl)
                modalOptions.templateUrl = this.templateUrl;
            if(this.template)
                modalOptions.template = this.template;
            if(this.parentScope)
                modalOptions.scope = this.parentScope;

            return modalOptions;

            function createCallbackWithScope(callback, scope) {
                return function() {
                    //Get the arguments of the original callback
                    var args = Array.prototype.slice.call(arguments);
                    callback(scope, args);
                };
            }
        };

        return ModalService;
    }]);
angular.module('BitchTV.plugins').factory('ResourceFactory',
    ["$resource", function($resource) {
        return {
            createResource : function(resourceInfo) {
                var idField = resourceInfo.idField;
                var apiUrl = resourceInfo.apiUrl + resourceInfo.route + "/:" + idField;

                var paramFieldInfo = {};
                paramFieldInfo[idField] = '@' + idField;

                var resource = $resource(apiUrl, {}, {
                    update: {method:'PUT', params:paramFieldInfo}
                });

                resource.getFromAvailable = function(availableResources, resourceId) {
                    if(availableResources == null)
                        return null;

                    for(var i=0; i<availableResources.length; i++) {
                        if(availableResources[i] != null && availableResources[i][idField] == resourceId)
                            return availableResources[i];
                    }
                };

                return resource;
            }
        }
    }]);
angular.module('BitchTV.plugins').factory('BasicSearchService', function () {
    return {
        searchFor: function(toSearch, objects) {
            var results = [];
            toSearch = trimString(toSearch); // trim it
            for(var i=0; i<objects.length; i++) {
                for(var key in objects[i]) {
                    if(typeof objects[i][key] == 'string' && objects[i][key].indexOf(toSearch)!=-1) {
                        if(!itemExists(results, objects[i])) results.push(objects[i]);
                    }
                }
            }
            return results;
        }
    };

    function trimString(s) {
        var l=0, r=s.length -1;
        while(l < s.length && s[l] == ' ') l++;
        while(r > l && s[r] == ' ') r-=1;
        return s.substring(l, r+1);
    }

    function compareObjects(o1, o2) {
        var k = '';
        for(k in o1) if(o1[k] != o2[k]) return false;
        for(k in o2) if(o1[k] != o2[k]) return false;
        return true;
    }

    function itemExists(haystack, needle) {
        for(var i=0; i<haystack.length; i++) if(compareObjects(haystack[i], needle)) return true;
        return false;
    }
});
angular.module('BitchTV.plugins').factory('DateUtilService', function () {
    return {
        currentDate: function() {
            var today   = new Date();
            var year    = today.getFullYear();
            var month   = (today.getMonth())+1;
            var day     = today.getDate();
            var current = (day<10 ? '0':'') + day + "/" + (month<10 ? '0':'') + month + "/" + year;
            return current;
        },

        currentTime: function() {
            var currentTime = new Date();
            var hours = currentTime.getHours();
            var minutes = currentTime.getMinutes();
            var current = (hours<10 ? '0':'') + hours + ':' + (minutes<10 ? '0':'') + minutes;
            return current;
        },
        getDayMonthYearByPrograms: getDayMonthYearByPrograms,
        getHoursMinutesByPrograms: getHoursMinutesByPrograms,

        getDateInfoForCode: function(dateCode) {
            var startTime;
            var stopTime;
            switch (dateCode) {
                case 'morning':
                    startTime = '08:00';
                    stopTime = '12:00';
                    break;

                case 'afternoon':
                    startTime = '12:00';
                    stopTime = '20:00';
                    break;

                case 'tonight':
                    startTime = '20:00';
                    stopTime = '08:00';
                    break;
                    
                case 'today':
                    startTime = '00:00';
                    stopTime = '23:59';
                    break;
            }
            return {
                startTime: startTime,
                stopTime: stopTime
            };
        }
    };

    function getDayMonthYearByPrograms(jsonDate)
    {
        jsonDate = jsonDate.toString();

        var dateYear = jsonDate.substring(0, 4);
        var dateMonth = jsonDate.substring(4,6);
        var dateDay = jsonDate.substring(6,8);

        var dateReturn = dateDay+'/'+dateMonth+'/'+dateYear;
        return dateReturn;
    }

    /*
     * Return a valid hour
     */

    function getHoursMinutesByPrograms(jsonDate)
    {
        jsonDate = jsonDate.toString();

        var dateHour = jsonDate.substring(8,10);
        var dateMinute = jsonDate.substring(10,12);

        var dateReturn = dateHour + ':' + dateMinute;
        return dateReturn;
    }
});
angular.module('BitchTV.plugins').factory('UtilService', function () {
    return {
        isInt: function (value) {
            return !isNaN(value) &&
                parseInt(Number(value)) == value &&
                !isNaN(parseInt(value, 10));
        }
    };
});
angular.module('BitchTV.plugins').factory('WaitingService',
    ["blockUI", function (blockUI) {
        return {
            start : function(callback) {
                blockUI.start();
                if(callback) {
                    setTimeout(function () {
                        callback();
                    }, 500);
                }
            },
            stop : function() {
                blockUI.stop();
            }
        }
    }]
);
angular.module('BitchTV.plugins').directive('modalContent', function () {
    return {
        restrict: 'E',
        transclude: true,
        templateUrl: 'components/plugins/modal/modalContent/modalContent.html',
        link: function (scope, element, attrs) {
            scope.title = attrs.title;
            scope.subtitle = attrs.subtitle;
        }
    };
});